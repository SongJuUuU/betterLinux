목표: 전원이 눌리면, os 파일을 적재한다. 메모리에.
부트로더가,

if 전기가 들어오고, 컴퓨터에 문제가 없으면,

os 파일을 ram에 적재한다.

리얼 모드라는게 있는데, 
ivt라는게 있는데
code segment + offset 패턴이 있는데.
rom에 있을 수도 있고, 다른 곳에 있을 수도 있고

이걸 생각해서 만들어야하는데,

결국 부트로더라는 것은 명확하게 파악하지는 못했네.

///////////////////

int0x13
이게 리얼모드에서 실행되는 것 같고,

목표: 램 위에 rom에 있는걸 올린다. 

라즈베리파이의 칩은 SoC인데, 이 안에는 read only메모리가 내장되어있어서
이 rom은 부팅시 sd카드의 첫번째 파티션을 확인하고, 정해진 파일을
찾아 로드하는 역할을 한다.

그러면 내가할일은
ram에 올릴거 만들고
올릴 방식 결정하고.. 
    올릴 방식: 전원이 들어오면, cpu가 바로 읽는다? 
   
.section .text  elf 포멧으로 생각해보자
 코드가 저장될 섹션을 지정하는 명령어이다.(저장?)
    아.. 그러네.. elf포멧에서 어디에 저장할거냐?
.section .data로 하게 되면 초기화된 데이터, 즉 전역변수에 저장하겠다.



.global _start
이건 뭐냐면? _start라는 레이블을 전역심볼로 선언한다. 

(전역 심볼이 무엇인가? )

이 코드는 프로그램의 시작점이 됨 
왜 필요한가?

어셈블리 코드를 컴파일해서 실행파일을 만들 때, 링커가 프로그램의
진입점을 찾아야함. _start 전역으로 선언하며 링커가 

전역심볼은 프로그램의 여러 파일에서 참조할 수 있는 심볼(함수 
또는 변수의 이름을 의미한다.)

그러면 언제 여러파일들로 쪼개지나? 
처음부터 여러파일일수도 있어.
예를 들면?

전역 심볼이되면 다른 파일에서도 참조할 수 있지만,
로컬 심볼이면 같은 파일 내에서만 접근이 가능하다. 

컴파일 과정에서 전역심볼이 가지는 의미

컴파일 과정에서 전역 심볼은 링커와 연관되어 중요한 역할을 한다
1. 전처리
2. 컴파일
2. 어셈블
4. 링킹

어셈블리코드는 바이너리 오브젝트 파일로 변환된다.
어셈블러가 할거고

오브젝트파일을 합쳐서 실행가능한 프로그램을 만들게 되는건데
이 때 전역 심볼이 중요하다. 링커는 .o 파일들을 합치면서 각 심볼이 어디에
있는지 찾아 연결해야한다. 

gcc -c main.c main.o라고 하면 c를 어셈블리(s)로 바꾸고
그 s를 o까지 바꾸면? 그 오브젝트 파일(바이너리)들을 
이제 링킹을 해야하는데..

실행가능한 프로그램은 어떤 형태를 띄어야하나?
elf?
그럼 이게 우리가 바탕화면에 있는 걸 누르면 실행되는 그런건가?
근데 그건 .exe파일 같은데..?

main.o 파일은 실행파일이 아니라 링킹이 필요한 상태의 바이너리 파일이다.

as my_function.s -o my_function.o
어셈블리코드를 어셈블하여 오브젝트 파일을 생성하는과정이다.
as: 어셈블러구나
역시 실행파일이 아니라 링킹이 필요한 상태의 바이너리 파일이다. 

ld 는 링커구나
ld main.o my_function.o -o program
링커를 사용하여 하나의 실행파일로 만듦

ld : gnu링커

s가 source이고 o가 object인가?

1. 공유라이브러리
공유라이브러리는 shared library .so파일은 여러 실행 파일이 공통으로
사용할 수 있는 코드(함수, 변수 등)을 포함한 바이너리 파일
즉 하나의 실행 파일이 아니라
여러 프로그램에서 공유할 수 있는
실행가능한 코드를 포함호고 있어.
이것도 가져오고 저것도 가져오겠네.
그래서 elf라고 하네. 실행파일이지만, link도 할 수 있어야해.

2. 정적링크 동적링크

공유라이브러리는 실행파일이 실행될 때, 동적으로 연결되어 사용됨
예제: 실행파일이 libm.so 수학 연산 라이브러리를 사용한다고 해보자
program 실행파일은 sqrt()같은 수학함수를 사용함
하지만 sqrt()는 실행파일 내부에 없고,
libm.so(수학라이브러리)에 있음.
프로그램을 실행하면, 운영체제(동적링커, ld.so)가 libm.so를 찾아서
메모리에 로드한 후, sqrt()를 사용할 수 있도록 연결해줌.
이거 lowlevel로 어떻게 동작하는거야? 

2-1. 어떤 라이브러리를 사용하는지 모아놓은 정보 부분이 있나?
일단 ldd라는 것을 이용하면 어떤 공유 라이브러리를 사용하는지 알 수 있다.
그리고, 바로가기 따닥이랑 shell명령이랑 다른가? 
아.. ls안에 여러가지 실행파일이 있나?
아니면 ls라는 걸 shell에 입력하면, 그게 실행하라는 명령인가?

3. 이미 실행 파일이 된 elf도 추가적으로 링크될 수 있다.

4. 오브젝트 파일은 아직 실행할 수 없는 중간단계의 파일이다.
바이너리 이더라고 링킹이 되지 않아서 실행할 수 없다.
오브젝트 파일은 보통 여려 개를 만들어서 링커(ld)가 합쳐져서 
하나의 실행파일을 만듦

실행파일은 여려개의 오브젝트 파일과 라이브러리 링크를 연결하여 생성됨.
내맘대로 예시를 생각해볼까?
뭐 이것저것 코드가 있는데, 어느부분을 가져올거야.
matplotlib이라고 하면, 거기에서 이런거 있나 찾지 않을까? 
그런걸 미리 확인하는 방식도 있겠고, 아닌 방식도 있겠고..

exe파일과 elf파일의 차이점.

exe파일은 windows에서 사용하는 실행 파일 형식이고,
elf는 linux및 unix계열에서 사용하는 실행파일 형식이다

그리고 라이브러리 확장자는 .so와 .dll(dynamic link library)로 다르다

elf 파일구조는

ELF Header
Program Header Table
Section Header Table
.text
.data
.bss

이렇게 되고, 이걸 분석하는 명령어 같은 것들도 미리 만들어 놓았을 것 같은데
readelf -h program : elf헤더 확인
objdump -x program : elf 내부구조 분석

------------------------------------------------------
로더도 알아야지.
결국 우리가 만들어야하는게 로더 아니야? 

로더는 디스크에 있는 실행 파일을 멜모리에 적재하고
실행을 하는 os 내의 프로그램인데,
정확히 말하면 아직은 os를 ram에 올리기 전이니까,
os를 올릴 수 있는 미니로더를 만들어야겠네.

로더의 주요기능
로더는 실행파일을 실행하기 위해 다음과 같은 작업을 수행
파일을 읽고 메모리에 로드
실행파일의 코드와 데이터를 ram에 올림
운영체제의 파일 시스템을 열고, 필요한 섹션을 읽어옴.
이게 무슨말이야?

메모리 주소 재배치
실행파일이 실제로 메모리에서 실행될 주소를 결정
왜 재배치야? 
실행 파일이 항상 같은 주소에서 실행되는게 아니라, 
가상 메모리 매핑을 통해 실행될 주소가 바뀔 수 있음.

동적 라이브러리를 로딩을 얘가 해줘야겠네.

.so .dll

새로운 프로세스를 생성하고, cpu의 명령어 포인터, instruction pointer
혹은 program counter
를 엔트리 포인트로 설정함

linux에서 elf 파일이 실행될 때 운영체제의 execve() 시스템 호출을 통해
로더가 실행파일을 적재함.

시스템 콜 누가하는거지? 
터미널에서 ./program 실행
bash가 execve("program", args, envp) 호출
커널의 로더가 실행파일을 디스크에서 읽어 메모리에 올림
elf헤더를 분석하여 프로그램을 실행할 가상 메모리 주소 결정(무조건인가?)
필요한 공유라이브러리를 ld.so가 로드
엔트리포인트로 점프하여 실행 시작

------------------------------------
 .section .text
.global _start

(.text 섹션에 저장할 것이고,
전역변수에 _start를 선언한다)

_start:
    LDR R0, =ROM_START     @ ROM의 시작 주소 (가상)
    LDR R1, =RAM_START     @ RAM의 시작 주소 (가상)
    LDR R2, =ROM_SIZE      @ 복사할 데이터 크기

(LDR이 뭐냐면 Load Register 명령어를 사용하여 레지스터에 값을 
로드하는 과정이다.
이 코드는 메모리 주소와 값을 레지스터에 로드하는 역할을 해.
LDR Rn, =값 : 즉시 값(주소 또는 데이터)를 로드
LDR Rn, [Rm] : Rm 레지스터가 가리키는 메모리 주소에서 값을 로드
LDR Rn, [Rm, #오프셋] : (Rm, 오프셋) 위치의 메모리에서 값을 로드)

=ROM_START는 값일 수도 있고, 주소일 수도 있겠지..

그리고 즉시 값을 다룰 때와 주소를 다룰 때,
cpu내부에서는 다르게 동작할 수 있다.

프로그래머 입장에서는 
ROM_START는 어딘가에 있는 메모리 주소를 의미함
R0 = 0x0000000000 이 될 것처럼 보임

cpu내부에서는
ARM에서는 LDR R0, =값 구문이 실제로는 다음 중 한가지로 동작함
1. mov 명령어 반환(주소가 12비트 이내일 경우)
- arm cpu는 12비트 이내의 값은 mov 명령어로 최적화 할 수 있다.
(arm cpu는 즉시값을 12비트까지 직접 로드할 수 있다.)ㄴㄴ
- LDR RO, =0x000000FF
이코드는 내부적으로 다음과 같이 변환될 수 있다.
- MOV R0, #0xFF 즉시 값을 R0에 저장

2. 리터럴 풀에서 불러오기 (주소가 12비트 이상일 경우)
LDR R0, =0x00000000000
이코드는 내부적으로 리터럴 풀을 사용하여 값(주소)를 불러오게됨
리터럴 풀이란?
arm 아키텍처는 큰 값을 직접 mov 명령어로 로드할 수 없음
해결책: 큰 값을 메모리의 특정 공간에 저장하고, 
LDR을 통해 불러옴.
<이부분 아직 이해안됨>

___________________________
기초적은 arm cpu의 기본구조 개요

arm cpu의 기본적인 구조를 이해하면 왜 즉시값(immediate Value) 로드가
12비트까지 제한되는지 같은 특성을 쉽게 파악할 수 있어.

ARM 아키텍처는 레지스터 기반의 RISC(reduced instruction set computer)
프로세서로,
명령어 집합과 내부구조가 단순하면서도 효율적인 설계를 가지고 있어.

arm 프로세서는 크게 다음과 같은 핵심 컴포넌트들로 구성된다.

1. 레지스터 구조
arm은 일반 purpose레지스터(GPR) 16개(R0-15)를 사용한다
0-12는 일반적인 데이터 저장 및 연산에 사용
13은(stack pointer) 스택의 현재 위치를 저장
14는 함수호출 후 복귀할 장소를 저장(link register)
15는 프로그램 카운터 (현재 실행중인 명령어의 주소를 저장)
프로그램 카운터와 스택 카운터는 다른거구나

2. 명령여 집합
arm cpu는 risc아키텍처를 사용한다.
고정된 32비트 명령어 또는 16비트 명령어를 사용한다.
이는 각각 arm모드와 thumb모드라고 하고
하나의 명령어가 한 클럭 사이클 내에 실행된다.

<하나의 명령어가 한 클럭 사이클 내에 실행됨 → 명령어 실행 속도가 빠름.>
질문하기

arm 명렁어는 보통 레지스터 기반으로 동작하며,
메모리 접근을 최소화하도록 설계되어 있다.

한클럭 사이클이랑 메모리접근

즉시값 [immediate value] 처리방식
arm은 32비트 프로세서지만, 즉시값을 처리하는 방식에 제한이 있음
대부분의 arm명령어는 즉시값을 12비트 이내로 표현할 수 있음.
이유는 arm명령어는 32비트로 크기가 고정되어 있으며,
명령어 자체에 즉시값을 포함할 공간이 한정적이기 때문이다.

arm에서는 #을 즉시값으로 사용하나보다

4. 메모리 구조 및 접근 방식
arm 프로세서는 로드/스토어 (load/store) 아키텍처를 사용한다.

즉, 연산은 모두 레지스터에서 수행하고, 
메모리에서 직접 연산을 수행할 수 없음
LDR(Load Register)/ STR(Store Register) 명령어를 통해서만
메모리와 데이터를 주고 받을 수 있다.

LDR 과 STR의 차이가 뭐지? 
아.. 메모리에서 레지스터로 가져오는게 load이고
레지스터에서 메모리로 보내는게 store구나? 

아.. R0라고 하면 레지스터고, 
[R1] 이라고 하면, R1에 적힌 메모리주소구나?

아.. 그래서 메모리와 레지스터 간에 왔다갔다 하는구나.

한 클럭 사이클 개념(clock cycle)
한 클럭 사이클이란?
cpu가 하나의 명령어를 실행하는데 걸리는 최소한의 시간 단위
클럭주파수(1GHz)는 초당 10억번의 클럭 사이클이 발생한다는 의미한다

대부분의 명령어를 1 클럭 사이클 내에 실행할 수 있도록 설계된다.
하지만 메모리 접근 (LDR/STR) 같은 일부 명령어는,
여러 클럭 사이클이 필요할 수 있다.

MOV R0, #42 : 1 클럭 사이클 (즉시값 로드)
LDR R0, [R1] : 2-4 클럭 사이클 (메모리 접근 필요)
메모리는 cpu 보다 느려서 LDR/STR 같은 명령어는 보통 여러 클럭이 걸림
메모리가 느린 이유는? 
    1. 메모리는 cpu 보다 물리적으로 멀다
        cpu L1 L2 L3 캐시 그리고 RAM에 도달한다
        cpu는 초고석 연산을 수행할 수 있지만, 메모리는 cpu 와 거리가
        멀기 때문에 신호가 전달되는데 시간이걸림
        cpu 내부에 캐시는 가깝지만, ram은 상대적으로 멀다

    2. RAM(DRAM)은  CPU 보다 전기적으로 느리다
        ram은 cpu와(캐시) 구조적으로 다름
        cpu는 sram(static ram)을 사용한다.
        그리고 sram은 플립플롭 기반이고
        dram은 커패시터터 기반이라고 하네.
        capacitor?
        DRAM은 캐퍼시터(축전기) 방식으로 데이터를 저장하며,
        시간이 지나면 전하가 방전됨.
        따라서 주기적으로 새로고침해야하므로 속도가 느림
        반면, sram은 플립플롭 방식으로 저장되므로 refresh가 필요 없고
        훨씬 빠르다

    3. cpu와 ram의 데이터 전송 방식 차이가
        cpu는 파이프라이닝과 분기예측 기술을 사용해 매우 빠르게 연산하지만,
        pipelining, branch prediction
        ram은 버스를 통해 데이터를 전달해야하므로 속도가 제한됨.
        cpu: 한 클럭 주기마다 명령어 실행(파이프라인구조)
        ram: cpu 요청을 받고 , 주소해석, 데이터 읽기, 전송 등의 작업 수행
        
        cpu는 초고속으로 연산하지만. ram은 데이터를 cpu로 보내는데 시간이 걸림

    4. memory bottleneck
        초당 수십억 개의 명령어를 처리할 수 있음(10GHz기준)
        근데 램은 그것보다 안되어서 cpu가 ram을 기다려야함

    참고로 아니 50에서 100클럭 걸린다며,
    근데 LDR 같은게 어떻게 2-4사이클 이내에 실행되는거야?

    정답: arm cpu는 캐시와 비순차 실행 같은 최적화 기법을
    사용하기 때문이야.
    cpu가 직접 ram에서 데이터를 가져오는 것이 아니라, 
    미리 가져온 데이터를 사용하거나,
    동시에 다른 작업을 수행하면서 기다리는 방식이다.
    캐시 히트는 2-4 클럭 만에 실행됨
    캐시미스 ram에서 데이터를 가져와야 하므로 100-300 클럭 걸림

    arm cpu는 메모리접근을 "비동기적으로" 수행할 수 있음
    arm cpu는 비순차 실행(out-of-order Execution)과 
    로드/스토어 분리(load/ store decoupling) 기술을 활용해서
    메모리 접근이 느려도 다른 연산을 먼저 수행하면서 기다릴 수 있음
    어떻게 설계가 되었길래 이런게 가능한 걸까?  

    프리페치(prefetch)
    arm은 메모리 접근을 미리 예측하고 데이터를 가져오는 프리페치 기술을
    사용한다.
    어떻게 예측하는데? 
    예측하는 원리가 뭐야? 
    이미 캐시나 레지스터에 저장된 데이터를 바로 사용한다.

    

    


5. 파이프라이닝
arm 프로세서는 3단계 파이프라인 구조(Fetch Decode Execute)를 
사용해서 명령어 실행 속도를 높임
하나의 명령어를 실행하면서, 동시에 다음 명령어를 가져오는 방식
이렇게 하면 실행속도가 빨라지고,
CPU의 자원을 효율적으로 사용할 수 있음
Fetch: 메모리에서 명령어 가져오기
Decode: 명령어 해석 및 실행 준비
Execute: 명령어 실행


copy_loop:
    LDRB R3, [R0], #1      @ ROM에서 1바이트를 읽고 R0를 증가
    STRB R3, [R1], #1      @ RAM에 1바이트를 저장하고 R1 증가
    SUBS R2, R2, #1        @ 남은 바이트 수 감소
    BNE copy_loop          @ R2가 0이 아니라면 반복

    B done                 @ 복사가 끝나면 종료

done:
    B done                 @ 무한 루프 (추후 실행 코드로 변경 가능)

.section .data
ROM_START: .word 0x08000000  @ 가상의 ROM 시작 주소
RAM_START: .word 0x20000000  @ 가상의 RAM 시작 주소
ROM_SIZE:  .word 256         @ 복사할 크기 (256바이트)

 ------------------------------------ 
 